@app.route('/retrievesectorhistorical/<stocks_id>')
def retrieveSectorHistorical(stocks_id):
	stocksList = stocks_id.split(',')
	stocks = []
	processedData = []
	changesZ = []
	maxP = 0.0
	minP = 100000.0
	stocksLength = len(stocksList)
	shortestStockIndex = 0
	rangePrices = 0.0
	for i, stock in enumerate(stocksList):
		# stocks.append(ys.historical(stock))
		stocks.append(ys.historical(stock, {'month':1, 'day': 1, 'year':1990},{'month':1, 'day': 1, 'year':2014}))
		# data[i]
	for i in range(stocksLength):
		if len(stocks[shortestStockIndex])>len(stocks[i]):
			shortestStockIndex = i
		for j in range(len(stocks[i])):
			temp = float(stocks[i][j][1])
			if temp > maxP:
				maxP = temp
			if temp < minP:
				minP = temp
	# minP -= 50
	rangePrices = (maxP-minP)/130.0
	# return str(minP)+" "+str(maxP)+" "+str(rangePrices)
	for i in range(len(stocks)):
		minT = 0.0	
		maxT = float(len(stocks[i]))
		print maxT
		rangeT = (maxT-minT)/130.0
		xAxis = []
		yAxis = []
		processedData.append({})
		processedData[i]['x'] = []
		processedData[i]['y'] = []
		processedData[i]['z'] = []
		changesZ.append([])
		changesZ[i].append(0)
		for j in range(len(stocks[i])):
			#thisTime = datetime.datetime.fromtimestamp(float(stocks[i][j][0]))
			#xAxis.append(str(((thisTime.hour*60+thisTime.minute-60*9)/3)-minT))
			if j!=0:
				xAxis.append(str(float(j)/float(rangeT)))
			else:
				xAxis.append(str(0))
			yAxis.append(str((float(stocks[i][j][1])-minP)/rangePrices))
			if j!=0:
				changesZ[i].append(\
					float(stocks[i][j][1])-\
					float(stocks[i][0][1])\
					)
			# the following avoids retrieving stocks from the last hours
			# if float(xAxis[len(xAxis)-1]) >= 130.0:
			# 	break
		changesZ[i][0] = changesZ[i][1]
		processedData[i]['x'] = xAxis
		processedData[i]['y'] = yAxis
	for j in range(1, len(stocks[shortestStockIndex])):
		tot = 0.0
		ztemporalR = []
		for i in range(len(stocks)):
			tot += float(changesZ[i][j])
		#print tot+","
		for i in range(len(stocks)):
			if (changesZ[i][j] != 0) and (tot != 0):
				ztemporalR.append(\
					float(changesZ[i][j]/tot*130)\
					)
				#print processedData[i][j][-1]
			else:
				# processedData[i]['z'][(len(processedData[i]['z'])-1)]
				ztemporalR.append(0.0)
		ztemporal = np.narray([ n for n in ztemporalR ])
		xtemporal = np.narray([ i for i in range(len(ztemporal))])
		equationFit = np.polyfit(xtemporal, ztemporal, 3)
		equation = np.poly1d(equationFit)
		processedData[i]['z'].append([equation(xValue) for xValue in xtemporal])
	return '^'.join([','.join(stock['x'])+"\n"+','.join(stock['y'])+"\n"+','.join(stock['z']) for stock in processedData])